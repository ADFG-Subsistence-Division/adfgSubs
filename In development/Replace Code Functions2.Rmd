---
title: "R Notebook"
output: html_notebook
---

```{r Replace YAML header}

foldersDashboard <- c(
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-Dashboard-Template-2025/R-Code/Step 1 - Extraction and Validation",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-Dashboard-Template-2025/R-Code/Step 2 - Standardize and Validate",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-Dashboard-Template-2025/R-Code/Demographics",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-Dashboard-Template-2025/R-Code/Step 4 - Income and Employment",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-Dashboard-Template-2025/R-Code/Step 5 - Harvest processing",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-Dashboard-Template-2025/R-Code/Step 6 - Assessments and summary",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-Dashboard-Template-2025/R-Code/Step 7 - SNA")

foldersYukonComps <- c(
  # "C:/Users/jmcoleman2/Documents/GitHub/Analysis-294-2024/R-Code/Step 1 - Extraction and Validation",
  # "C:/Users/jmcoleman2/Documents/GitHub/Analysis-294-2024/R-Code/Step 2 - Standardize and Validate",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-294-2024/R-Code/Step 3 - Demographics",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-294-2024/R-Code/Step 4 - Income and Employment",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-294-2024/R-Code/Step 5 - Harvest processing",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-294-2024/R-Code/Step 6 - Assessments and summary",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-294-2024/R-Code/Step 7 - SNA")
  
foldersAmbler <- c(
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-316/R-Code/Step 1 - Extraction and Validation",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-316/R-Code/Step 2 - Standardize and Validate",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-316/R-Code/Step 3 - Demographics",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-316/R-Code/Step 4 - Income and Employment",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-316/R-Code/Step 5 - Harvest processing",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-316/R-Code/Step 6 - Assessments and summary")
  
foldersKivalina <-c(
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-313/R-Code/Step 1 - Extraction and Validation",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-313/R-Code/Step 2 - Standardize and Validate",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-313/R-Code/Step 3 - Demographics",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-313/R-Code/Step 4 - Income and Employment",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-313/R-Code/Step 5 - Harvest processing",
  "C:/Users/jmcoleman2/Documents/GitHub/Analysis-313/R-Code/Step 6 - Assessments and summary"
)  
  
filesKivalinaStep2 <- unlist(
  lapply(foldersKivalina[2], function(dir) list.files(dir, pattern = "\\.Rmd$", full.names = TRUE, recursive = TRUE))
)
filesAmblerStep2 <- unlist(
  lapply(foldersAmbler[2], function(dir) list.files(dir, pattern = "\\.Rmd$", full.names = TRUE, recursive = TRUE))
)

# Still duplicates HTML and I'm not sure why

replaceYAML <- function(
  files = NULL,
  folders = NULL,
  pattern = "\\.Rmd$",
  author = NULL,
  date = NULL,
  html_lines = NULL,
  output_lines = c(
    "  html_document:",
    "    theme: null",
    "    css: ../HTML/adfg-style.css",
    "    include:",
    "      before_body: ../HTML/header.html",
    "      after_body: ../HTML/footer.html"
  ),
  suffix = NULL
) {
  # Collect files from folders if needed
  if (!is.null(folders)) {
    files_from_folders <- unlist(
      lapply(folders, function(dir) list.files(dir, pattern = pattern, full.names = TRUE, recursive = TRUE))
    )
    files <- unique(c(files, files_from_folders))
  }
  files <- files[!is.na(files) & file.exists(files)] # Filter valid files
  
  results <- data.frame(
    file = files,
    status = NA_character_,
    message = NA_character_,
    stringsAsFactors = FALSE
  )
  
  for (i in seq_along(files)) {
    file <- files[i]
    res <- tryCatch({
      
      lines <- readLines(file, warn = FALSE)
      
      yaml_starts <- which(trimws(lines) == "---")
      
      file_base <- tools::file_path_sans_ext(basename(file))
      # Construct html_lines if NULL
      if (is.null(html_lines)) {
        html_lines_use <- c(
          '<div class="title-container">',
          '  <img class="title-logo" src="../HTML/adfg_logo.png" alt="ADFG Logo"/>',
          sprintf('  <div class="title">%s %s</div>', file_base, suffix),
          "</div>"
        )
      } else {
        html_lines_use <- html_lines
      }

      # Check if html_lines already exist (all lines must appear in sequence)
      html_exists <- FALSE
      if (length(html_lines_use) > 0) {
        # Collapse file lines into a single string and check for the pattern
        file_text <- paste(lines, collapse = "\n")
        html_text <- paste(html_lines_use, collapse = "\n")
        html_exists <- grepl(html_text, file_text, fixed = TRUE)
      }
      
      # If html_lines already present, skip adding them
      if (html_exists) {
        html_lines_to_add <- character(0)
        html_message <- "HTML already present"
      } else {
        html_lines_to_add <- html_lines_use
        html_message <- "YAML and HTML replaced"
      }

      if (length(yaml_starts) >= 2) {
        new_header <- c(
          "---",
          sprintf('title: "%s %s"', file_base, suffix),
          sprintf('author: "%s"', author),
          sprintf('date: "%s"', date),
          "output:",
          output_lines,
          "---",
          html_lines_to_add
        )
        before <- if (yaml_starts[1] > 1) lines[1:(yaml_starts[1] - 1)] else character(0)
        after <- lines[(yaml_starts[2] + 1):length(lines)]
        new_lines <- c(before, new_header, after)
        writeLines(new_lines, file)
        message(sprintf("Updated: %s", file))
        results$status[i] <- "updated"
        results$message[i] <- html_message
      } else {
        warning(sprintf("YAML header not found: %s", file))
        results$status[i] <- "skipped"
        results$message[i] <- "YAML header not found"
      }
    }, error = function(e) {
      warning(sprintf("Error processing %s: %s", file, e$message))
      results$status[i] <- "error"
      results$message[i] <- e$message
    })
  }
  invisible(results)
}

replaceYAML(files = filesKivalinaStep2[c(5:15)],
            author = c("Jesse Coleman"),
            date = c("2025-08-18"),
            suffix = c("- (313) SWG Kivalina Comprehensive"))

replaceYAML(files = filesAmblerStep2,
            author = c("Jesse Coleman"),
            date = c("2025-08-19"),
            suffix = c("- (316) NPS Ambler Comprehensive"))

```

```{r Replace code chunk}

replaceCodeChunks <- function(
  path = ".",
  pattern = "\\.Rmd$",
  exclude = NULL,           # vector of filenames to exclude
  chunk_label = NULL,       # code chunk label, e.g., "write csv files"
  new_code = NULL,          # new code, as a vector of lines (no chunk header/footer)
  rec_pattern = "REC[0-9]{2}",
  rec_placeholder = "REC_PLACEHOLDER"
) {
  files <- list.files(path, pattern = pattern, full.names = TRUE)
  if (!is.null(exclude)) {
    files <- files[!basename(files) %in% exclude]
  }
  
  for (file in files) {
    lines <- readLines(file)
    # Find chunk start by label
    chunk_start <- grep(paste0("^```\\{r[ ,].*", chunk_label, ".*\\}"), lines)
    if (length(chunk_start) == 0) {
      message(sprintf("Chunk label '%s' not found in %s. Skipping.", chunk_label, file))
      next
    }
    # Find chunk end (first ``` after chunk_start)
    chunk_end <- which((seq_along(lines) > chunk_start) & grepl("^```$", lines))[1]
    if (is.na(chunk_end)) {
      message(sprintf("Could not find end of chunk after '%s' in %s. Skipping.", chunk_label, file))
      next
    }
    # Extract RECxx value from the old chunk body
    chunk_body <- lines[(chunk_start+1):(chunk_end-1)]
    rec_matches <- regmatches(chunk_body, gregexpr(rec_pattern, chunk_body))
    rec_value <- unique(unlist(rec_matches))
    if (length(rec_value) > 0) {
      rec_value <- rec_value[1]
      # Replace placeholder in new code with the actual RECxx value
      new_code_fixed <- gsub(rec_placeholder, rec_value, new_code)
    } else {
      new_code_fixed <- new_code
    }
    # Rebuild lines: everything before chunk_start, chunk header, new_code_fixed, chunk footer, everything after chunk_end
    new_lines <- c(
      lines[1:(chunk_start-1)],
      lines[chunk_start],   # chunk header (once)
      new_code_fixed,
      lines[chunk_end]      # chunk footer (once)
    )
    if (chunk_end < length(lines)) {
      new_lines <- c(new_lines, lines[(chunk_end+1):length(lines)])
    }
    writeLines(new_lines, file)
    message(sprintf("Updated chunk '%s' in %s.", chunk_label, file))
  }
}


newCode <- c("# Set some knit options and functions for formatting data.
knitr::opts_chunk$set(echo = FALSE,
                      include = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      results='asis')

options(knitr.kable.NA = '')"
)


replaceCodeChunks(path = foldersAmbler,
                  chunk_label = "setup",
                  new_code = newCode)

replaceCodeChunks(path = foldersKivalina,
                  chunk_label = "setup",
                  new_code = newCode)

replaceCodeChunks(path = foldersYukonComps,
                  chunk_label = "setup",
                  new_code = newCode)


```

```{r Insert code chunk}

insertChunkAfter <- function(
  path = ".",
  pattern = "\\.Rmd$",
  after_chunk_label,      # e.g., "setup" for chunk labeled {r setup}
  new_header = NULL,      # e.g., "## New Step"
  new_text = NULL,        # e.g., "This section does something new."
  new_chunk = NULL        # vector of lines for the new chunk
) {
  files <- list.files(path, pattern = pattern, full.names = TRUE)
  
  for (file in files) {
    lines <- readLines(file)
    # Find start of target chunk by label
    chunk_starts <- grep(paste0("^```\\{r[ ,].*", after_chunk_label, ".*\\}"), lines)
    if (length(chunk_starts) == 0) {
      message(sprintf("Chunk label '%s' not found in %s. Skipping.", after_chunk_label, file))
      next
    }
    # Find end of that chunk (the first ``` after the chunk start)
    chunk_ends <- sapply(chunk_starts, function(start) {
      end <- which((seq_along(lines) > start) & grepl("^```$", lines))[1]
      if (!is.na(end)) return(end) else return(NA)
    })
    # Only proceed if both start and end are found
    if (any(is.na(chunk_ends))) {
      message(sprintf("Could not find end of chunk after '%s' in %s. Skipping.", after_chunk_label, file))
      next
    }
    # We'll only process the first occurrence for simplicity
    insert_pos <- chunk_ends[1]
    # Prepare insertion lines
    insertion <- c()
    if (!is.null(new_header)) insertion <- c(insertion, new_header)
    if (!is.null(new_text)) insertion <- c(insertion, new_text)
    if (!is.null(new_chunk)) insertion <- c(insertion, new_chunk)
    # Insert after the found chunk end
    new_lines <- append(lines, insertion, after = insert_pos)
    writeLines(new_lines, file)
    message(sprintf("Inserted new chunk after '%s' in %s.", after_chunk_label, file))
  }
}

newHeader <-c("## Conversion factors for unspecified resources")

newText <- c("Resources are often reported as 'unspecified', in cases where the survey respondent
was unsure of the species harvested or received. To calculate the edible weight of 
unspecified resources harvested, similar resources and the amounts/weights harvested
are used to calculate the conversion factor for unspecified resources. Analysts must
develop a list of resources to use in this calculation for each unspecified resource.")

newChunk <-c()

insert_chunk_after(path = folders[2],
                   after_chunk_label = "standardize units",
                   new_header = newHeader,
                   new_text =  newText,
                   new_chunk = newChunk)



```

```{r Find and delete text} 

find_and_delete_text <- function(
  files = NULL,
  folders = NULL,
  pattern = "\\.Rmd$",
  text_to_delete,
  fixed = TRUE,
  recursive = TRUE,
  verbose = TRUE
) {
  # Collect files from folders if specified
  if (!is.null(folders)) {
    files_from_folders <- unlist(
      lapply(folders, function(dir) list.files(dir, pattern = pattern, full.names = TRUE, recursive = recursive))
    )
    files <- unique(c(files, files_from_folders))
  }
  files <- files[!is.na(files) & file.exists(files)] # filter valid files
  if(length(files) == 0) {
    if(verbose) message("No files found.")
    return(invisible(NULL))
  }

  results <- data.frame(
    file = files,
    status = NA_character_,
    message = NA_character_,
    stringsAsFactors = FALSE
  )

  for (i in seq_along(files)) {
    file <- files[i]
    res <- tryCatch({
      lines <- readLines(file, warn = FALSE)
      # Remove lines containing the target text
      to_remove <- grepl(text_to_delete, lines, fixed = fixed)
      if(any(to_remove)) {
        new_lines <- lines[!to_remove]
        writeLines(new_lines, file)
        if(verbose) message(sprintf("Deleted lines in: %s", file))
        results$status[i] <- "updated"
        results$message[i] <- sprintf("Deleted %d line(s)", sum(to_remove))
      } else {
        if(verbose) message(sprintf("No matching text found in: %s", file))
        results$status[i] <- "skipped"
        results$message[i] <- "No matching text"
      }
    }, error = function(e) {
      warning(sprintf("Error processing %s: %s", file, e$message))
      results$status[i] <- "error"
      results$message[i] <- e$message
    })
  }
  invisible(results)
}


find_and_delete_text(files = filesAmblerStep2,
                     text_to_delete = c('<div class="title-container">
  <img class="title-logo" src="../HTML/adfg_logo.png" alt="ADFG Logo"/>
  <div class="title">B01_PREP_SAMPLE - (313) SWG Kivalina Comprehensive</div>
</div>'))

```

```{r Find and replace text}

find_and_replace_text <- function(
  files = NULL,
  folders = NULL,
  pattern = "\\.Rmd$",
  find,
  replace,
  fixed = TRUE,
  recursive = TRUE,
  verbose = TRUE
) {
  # Check arguments
  if (length(find) != length(replace)) {
    stop("'find' and 'replace' must be the same length.")
  }
  if (!is.character(find) || !is.character(replace)) {
    stop("'find' and 'replace' must be character vectors.")
  }

  # Collect files from folders if specified
  if (!is.null(folders)) {
    files_from_folders <- unlist(
      lapply(folders, function(dir) list.files(dir, pattern = pattern, full.names = TRUE, recursive = recursive))
    )
    files <- unique(c(files, files_from_folders))
  }
  files <- files[!is.na(files) & file.exists(files)] # filter valid files
  if(length(files) == 0) {
    if(verbose) message("No files found.")
    return(invisible(NULL))
  }

  results <- data.frame(
    file = files,
    status = NA_character_,
    message = NA_character_,
    stringsAsFactors = FALSE
  )

  for (i in seq_along(files)) {
    file <- files[i]
    res <- tryCatch({
      lines <- readLines(file, warn = FALSE)
      original_lines <- lines
      # Apply replacements, pairwise
      for (j in seq_along(find)) {
        lines <- gsub(find[j], replace[j], lines, fixed = fixed)
      }
      changed <- !identical(original_lines, lines)
      if (changed) {
        writeLines(lines, file)
        if (verbose) message(sprintf("Replaced text in: %s", file))
        results$status[i] <- "updated"
        results$message[i] <- "Text replaced"
      } else {
        if (verbose) message(sprintf("No matching text found in: %s", file))
        results$status[i] <- "skipped"
        results$message[i] <- "No matching text"
      }
    }, error = function(e) {
      warning(sprintf("Error processing %s: %s", file, e$message))
      results$status[i] <- "error"
      results$message[i] <- e$message
    })
  }
  invisible(results)
}

find_and_replace_text(
  folders = c("docs"),
  find = c("oldtext1", "oldtext2"),
  replace = c("newtext1", "newtext2")
)
```

```{r Batch knit to PDF}

library(tinytex)
library(tidyverse)
library(purrr)
library(fs) # for file system operations (optional but convenient)

# Find all .Rmd files in the specified folders
files <- map(foldersYukonComps, ~ dir_ls(.x, regexp = "\\.Rmd$", recurse = FALSE)) %>% 
  flatten_chr()

# Render each .Rmd file to PDF
walk(files, ~ rmarkdown::render(.x, output_format = "html_document"))
```

